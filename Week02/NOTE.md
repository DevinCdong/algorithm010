## 学习笔记

1. 树的遍历通常用递归，迭代方法则需要借助额外的栈，一种比较直观的方式是颜色标记法，第一次遇到的节点标记为灰色，将其从栈中取出之后，根据前序/中序/后序放入其子节点及该节点，对前序即先放右子、再放左子、最后放该节点并标记为白色。

2. hashmap是一个重要的结构，在2/3数和许多递归/分治的场景下都有极其广泛的应用。
java实现中其使用了至少3种数据结构，一是数组，二是链表，三是红黑树。
虽然一般的数据类型会有从object继承的hash方法用于计算hash code，但hashmap为了更好的分散取值会将这一code再散列一次。
hash code首先会用于在数组中寻找下标（桶）。为了可以快速的找到桶，数组大小被限制为2的幂次，这样可以利用(1<<n-1，<<优先级高于减法)作为**掩码**来用位运算找到桶，计算方式即 hash code & (1<<n-1)。数组有负载因子0.75，即数组中非空元素占比达到75%时将数组大小翻倍。容量扩张过程中，同一个桶内的元素在平均情况下会被均分到高低位的两个桶中，例如长32的数组中（最大地址0x11111=32-1），原本都在0x10011这个桶中的元素，在扩张至64后（最大地址0x111111=64-1）有约一半的元素会进入0x110011这个高位桶，而另一半仍旧留在原来的低位桶中，因为0x100000=32。因此，数组的大小起到的作用实际上和ip地址中的子网掩码类似。
进入同一个桶的元素（键值对），会因地址冲突而在初期使用链表相互关联。和上一条扩容移动元素所说的类似，这些键只在hash code的高地址位（不会被数组大小掩码掉）有差异；低地址位都用于映射到同一个桶了（被数组大小掩码掉了），因此是一样的。当链表长度达到8之后，继续加入元素时，链表转为红黑树。由于红黑树只能依据hash code比较大小找到唯一的节点，当多个节点有同样的hash code时，它们会映射到同一个桶的树的同一个节点上，此时红黑树还是会采用链地址法将数据关联起来。对于输入的键，判定真正找到该键的依据还是要看键对象的==或equals方法，hash code只是用于加速查找，不能唯一确定键。
当使用率下降时，红黑树会退化为链表，数组大小也会收缩以节省资源。
